{
  "package": "tsa_lth",
  "generated_by": "assistant",
  "modules": {
    "tsa_lth.analysis": {
      "description": "Core time-series analysis and plotting helpers.",
      "functions": {
        "acf": "Compute auto-correlation function (lags, conf intervals).",
        "pacf": "Partial auto-correlation using robust Yule-Walker implementation (replaced legacy pacf).",
        "tacf": "Time-lagged auto-correlation (helper).",
        "plotACFnPACF": "Plot ACF and PACF together; supports options for lags and axes.",
        "plot_cum_per": "Cumulative periodogram plotting helper.",
        "xcorr": "Cross-correlation with optional normalization/lag handling.",
        "ccf": "Cross-correlation function for two time series.",
        "resid": "Helper to compute residuals using filter-based approach if needed.",
        "pzmap": "Pole-zero map plotting; accepts 'ax' matplotlib axis and 'show' flag; robust to scalar coefficients.",
        "normplot": "Normal probability plot helper with options for axes/show.",
        "box_cox": "Box-Cox transform helper."
      },
      "notes": "Many plotting helpers were extended to accept an 'ax' argument and 'show' flag so notebooks can control plt.show. PACF was replaced with a robust Yule-Walker variant."
    },
    "tsa_lth.modelling": {
      "description": "Model estimation, simulation, prediction and PEM (Prediction Error Minimization) utilities.",
      "classes": {
        "PEM": {
          "description": "Estimate ARMAX/ARMA/BJ models using prediction error minimization.",
          "methods": [
            "__init__(y,x=None,A=[1],B=[],C=[1],D=[1],F=[1],diff=None)",
            "fit(method='LS', bh=False, bh_iter=100) -> PEMResult",
            "rpem(P=None, Q=None, R=None, k_pred=None) -> dict (recursive estimation via Kalman)",
            "set_free_params(...)"
          ]
        },
        "PEMResult": {
          "description": "Result container returned by PEM.fit with convenience methods.",
          "methods": [
            "summary(return_val=False) -> str or None",
            "predict(k=1) -> array",
            "forecast(n=3) -> array",
            "plotll(...)"
          ]
        }
      },
      "functions": {
        "filter": "Apply linear filter Y = B/A * X (wrapper around scipy.signal.lfilter). Handles int inputs and dtype casting; supports 'remove' of initial corrupt samples.",
        "difference": "Seasonal differencing helper using filter(..., remove=...).",
        "estimateBJ": "Fit Box-Jenkins model via PEM and perform diagnostics (plotACFnPACF, whiteness_test).",
        "estimateARMA": "Fit ARMA via PEM with diagnostics.",
        "simulateARMA": "Simulate an ARMA series given AR/MA polynomials or orders.",
        "generate_stable_coefficients": "Generate stable AR/MA polynomials (roots outside unit circle convention in this code).",
        "simulate_model": "Simulate general A,B,C,D,F model.",
        "set_order": "Helper to build an order mask array (1s at specified indices).",
        "equal_length": "Pad multiple iterables to equal lengths by zero-filling.",
        "polydiv": "Polynomial division helper (returns F,G from C = A*F + z^-k G).",
        "recursiveAR": "Recursive least-squares AR estimation (RLS).",
        "recursiveARMA": "Recursive RLS for ARMA-like models.",
        "predict_pem": "Compute k-step predictions for a fitted PEMResult.",
        "prediction_residual": "Return prediction residuals (actual - predicted).",
        "show_model": "Backward-compatibility helper to pretty-print ARMA parameters (replaced by PEMResult.summary)."
      },
      "notes": "The PEM implementation uses scipy.optimize for LS/minimization and contains helper methods to convert between theta and polynomial forms. 'filter' ensures float dtype for scipy.signal.lfilter compatibility."
    },
    "tsa_lth.tests": {
      "description": "Statistical tests and whiteness checks used across notebooks and examples.",
      "functions": {
        "monti_test": "Monti whiteness test (Q-statistic). Uses residual trimming consistent with MATLAB version when used with K=25 in examples.",
        "lbp_test": "Ljung-Box-Pierce type test wrapper/variant.",
        "ml_test": "Maximum-likelihood based tests (helper wrappers around statistical metrics).",
        "test_mean": "Mean test compatible with MATLAB 'testMean' semantics (returns scalar values when return_val=True).",
        "whiteness_test": "High-level whiteness test orchestration using monti/lbp variants and plotting helpers.",
        "count_sign_changes": "Utility to count sign changes in a series.",
        "check_if_normal": "Normality test wrapper(s) used by diagnostics.",
        "fisher_test": "Fisher test wrapper used for spectral comparisons.",
        "bolviken_test": "Bolviken test wrapper."
      },
      "notes": "Where tools/testMean.py existed as a legacy helper returning arrays, canonical 'test_mean' in this module provides consistent scalar outputs; notebooks were migrated to call test_mean(..., return_val=True) to get scalars for formatted printing."
    }
  },
  "tools": {
    "description": "Small helper scripts and ports (kept under tsa_lth/tools). Many are MATLAB ports or user-supplied utilities.",
    "files": [
      "pyulear.py (user-supplied Yule-Walker PSD estimator)",
      "esacf.py (ported ESACF algorithm from MATLAB; functions: ar_iter_esacf, ar_covariance_method, esacf)",
      "monti.py",
      "lbp.py",
      "ml.py",
      "ccf.py",
      "poly.py",
      "sign.py",
      "normalTest.py",
      "niceplot.py",
      "plot.py",
      "bolviken.py",
      "mjbtest.py",
      "metrics.py",
      "fft.py",
      "fisher.py",
      "whitenessTest.py",
      "testMean.py (legacy; returns array-structured results; notebooks updated to canonical tests)",
      "others... (see tsa_lth/tools directory for full list)"
    ],
    "notes": "Tools contain both canonical and legacy functions; consider harmonizing duplicate functionality (e.g., testMean vs tests.test_mean) in a follow-up."
  },
  "notebooks_updated": [
    {
      "path": "python/code1.ipynb",
      "notes": "Updated to import analysis and modelling functions from package 'tsa_lth' instead of local 'functions' folder."
    },
    {
      "path": "python/code2.ipynb",
      "notes": "Replaced zplane usage with tsa_lth.analysis.pzmap accepting 'ax' and 'show' flags; plotting adjusted."
    },
    {
      "path": "python/code3.ipynb",
      "notes": "Adjusted PACF usage to new pacf (Yule-Walker) and ensured plotting helpers accept axes."
    },
    {
      "path": "python/code4.ipynb",
      "notes": "Switched from tools.testMean to tsa_lth.tests.test_mean(return_val=True) and fixed residual shaping/formatting; monti_test called with K=25 to be consistent with MATLAB example."
    },
    {
      "path": "python/code5.ipynb",
      "notes": "Removed legacy system_id dependency; emulated 'resid' behavior with filter-based approach and zeroed initial corrupt samples; updated plotting calls."
    }
  ],
  "notes": {
    "verification": "Selected smoke tests were run during migration: monti_test on a synthetic AR(1) example, ESACF shapes verified, lfilter dtype issue resolved by casting input to float, and test_mean scalar output formatting fixed.",
    "recommendations": [
      "Install package in editable mode (pip install -e .) for notebooks to import without sys.path hacks.",
      "Unify duplicate helpers between tsa_lth.tests and tsa_lth.tools (e.g., testMean).",
      "Add a small test suite verifying monti_test, pacf, esacf smoke outputs (shapes & numeric invariants)."
    ]
  }
}
